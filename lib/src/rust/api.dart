// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import 'frb_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

Future<MetadataData> convertMetadataToData({required Metadata metadata}) =>
    RustLib.instance.api.crateApiConvertMetadataToData(metadata: metadata);

Future<Metadata> convertMetadataDataToMetadata({
  required MetadataData metadataData,
}) => RustLib.instance.api.crateApiConvertMetadataDataToMetadata(
  metadataData: metadataData,
);

Future<RelayType> relayTypeNostr() => RustLib.instance.api.crateApiRelayTypeNostr();

Future<RelayType> relayTypeInbox() => RustLib.instance.api.crateApiRelayTypeInbox();

Future<RelayType> relayTypeKeyPackage() => RustLib.instance.api.crateApiRelayTypeKeyPackage();

Future<PublicKey> publicKeyFromString({required String publicKeyString}) =>
    RustLib.instance.api.crateApiPublicKeyFromString(
      publicKeyString: publicKeyString,
    );

Future<RelayUrl> relayUrlFromString({required String url}) =>
    RustLib.instance.api.crateApiRelayUrlFromString(url: url);

Future<String> getRelayUrlString({required RelayUrl relayUrl}) =>
    RustLib.instance.api.crateApiGetRelayUrlString(relayUrl: relayUrl);

Future<WhitenoiseConfigData> convertConfigToData({
  required WhitenoiseConfig config,
}) => RustLib.instance.api.crateApiConvertConfigToData(config: config);

Future<AccountData> convertAccountToData({required Account account}) =>
    RustLib.instance.api.crateApiConvertAccountToData(account: account);

Future<String> groupIdToString({required GroupId groupId}) =>
    RustLib.instance.api.crateApiGroupIdToString(groupId: groupId);

Future<GroupId> groupIdFromString({required String hexString}) =>
    RustLib.instance.api.crateApiGroupIdFromString(hexString: hexString);

Future<GroupData> convertGroupToData({required Group group}) =>
    RustLib.instance.api.crateApiConvertGroupToData(group: group);

Future<WhitenoiseConfig> createWhitenoiseConfig({
  required String dataDir,
  required String logsDir,
}) => RustLib.instance.api.crateApiCreateWhitenoiseConfig(
  dataDir: dataDir,
  logsDir: logsDir,
);

Future<void> initializeWhitenoise({required WhitenoiseConfig config}) =>
    RustLib.instance.api.crateApiInitializeWhitenoise(config: config);

Future<AccountData> getAccountData({required Account account}) =>
    RustLib.instance.api.crateApiGetAccountData(account: account);

Future<WhitenoiseConfigData> getConfigData({
  required WhitenoiseConfig config,
}) => RustLib.instance.api.crateApiGetConfigData(config: config);

Future<void> deleteAllData() => RustLib.instance.api.crateApiDeleteAllData();

Future<List<AccountData>> fetchAccounts() => RustLib.instance.api.crateApiFetchAccounts();

Future<Account> createIdentity() => RustLib.instance.api.crateApiCreateIdentity();

Future<Account> login({required String nsecOrHexPrivkey}) =>
    RustLib.instance.api.crateApiLogin(nsecOrHexPrivkey: nsecOrHexPrivkey);

Future<void> logout({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiLogout(pubkey: pubkey);

Future<String> exportAccountNsec({required Account account}) =>
    RustLib.instance.api.crateApiExportAccountNsec(account: account);

Future<String> exportAccountNpub({required Account account}) =>
    RustLib.instance.api.crateApiExportAccountNpub(account: account);

Future<MetadataData?> fetchMetadata({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiFetchMetadata(pubkey: pubkey);

Future<void> updateMetadata({
  required MetadataData metadata,
  required Account account,
}) => RustLib.instance.api.crateApiUpdateMetadata(
  metadata: metadata,
  account: account,
);

Future<List<RelayUrl>> fetchRelays({
  required PublicKey pubkey,
  required RelayType relayType,
}) => RustLib.instance.api.crateApiFetchRelays(
  pubkey: pubkey,
  relayType: relayType,
);

Future<void> updateRelays({
  required Account account,
  required RelayType relayType,
  required List<RelayUrl> relays,
}) => RustLib.instance.api.crateApiUpdateRelays(
  account: account,
  relayType: relayType,
  relays: relays,
);

Future<Event?> fetchKeyPackage({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiFetchKeyPackage(pubkey: pubkey);

Future<OnboardingState> fetchOnboardingState({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiFetchOnboardingState(pubkey: pubkey);

Future<Map<PublicKey, MetadataData?>> fetchContacts({
  required PublicKey pubkey,
}) => RustLib.instance.api.crateApiFetchContacts(pubkey: pubkey);

Future<void> addContact({
  required Account account,
  required PublicKey contactPubkey,
}) => RustLib.instance.api.crateApiAddContact(
  account: account,
  contactPubkey: contactPubkey,
);

Future<void> removeContact({
  required Account account,
  required PublicKey contactPubkey,
}) => RustLib.instance.api.crateApiRemoveContact(
  account: account,
  contactPubkey: contactPubkey,
);

Future<void> updateContacts({
  required Account account,
  required List<PublicKey> contactPubkeys,
}) => RustLib.instance.api.crateApiUpdateContacts(
  account: account,
  contactPubkeys: contactPubkeys,
);

/// Fetch all active groups for an account
Future<List<GroupData>> fetchGroups({required Account account}) =>
    RustLib.instance.api.crateApiFetchGroups(account: account);

/// Fetch group members for a group
Future<List<PublicKey>> fetchGroupMembers({
  required Account account,
  required GroupId groupId,
}) => RustLib.instance.api.crateApiFetchGroupMembers(
  account: account,
  groupId: groupId,
);

/// Fetch groups admins for a group
Future<List<PublicKey>> fetchGroupAdmins({
  required Account account,
  required GroupId groupId,
}) => RustLib.instance.api.crateApiFetchGroupAdmins(
  account: account,
  groupId: groupId,
);

/// Create a group
Future<GroupData> createGroup({
  required Account creatorAccount,
  required List<PublicKey> memberPubkeys,
  required List<PublicKey> adminPubkeys,
  required String groupName,
  required String groupDescription,
}) => RustLib.instance.api.crateApiCreateGroup(
  creatorAccount: creatorAccount,
  memberPubkeys: memberPubkeys,
  adminPubkeys: adminPubkeys,
  groupName: groupName,
  groupDescription: groupDescription,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Account>>
abstract class Account implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>
abstract class Event implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Group>>
abstract class Group implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GroupId>>
abstract class GroupId implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Metadata>>
abstract class Metadata implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MetadataData>>
abstract class MetadataData implements RustOpaqueInterface {
  String? get about;

  String? get banner;

  String? get displayName;

  String? get lud06;

  String? get lud16;

  String? get name;

  String? get nip05;

  String? get picture;

  String? get website;

  set about(String? about);

  set banner(String? banner);

  set displayName(String? displayName);

  set lud06(String? lud06);

  set lud16(String? lud16);

  set name(String? name);

  set nip05(String? nip05);

  set picture(String? picture);

  set website(String? website);

  Future<Map<String, String>> getCustom();

  Future<void> setCustom({required Map<String, String> customMap});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
abstract class PublicKey implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RelayType>>
abstract class RelayType implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RelayUrl>>
abstract class RelayUrl implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WhitenoiseConfig>>
abstract class WhitenoiseConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WhitenoiseError>>
abstract class WhitenoiseError implements RustOpaqueInterface {}

class AccountData {
  final String pubkey;
  final AccountSettings settings;
  final OnboardingState onboarding;
  final BigInt lastSynced;

  const AccountData({
    required this.pubkey,
    required this.settings,
    required this.onboarding,
    required this.lastSynced,
  });

  @override
  int get hashCode =>
      pubkey.hashCode ^ settings.hashCode ^ onboarding.hashCode ^ lastSynced.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccountData &&
          runtimeType == other.runtimeType &&
          pubkey == other.pubkey &&
          settings == other.settings &&
          onboarding == other.onboarding &&
          lastSynced == other.lastSynced;
}

class AccountSettings {
  final bool darkTheme;
  final bool devMode;
  final bool lockdownMode;

  const AccountSettings({
    required this.darkTheme,
    required this.devMode,
    required this.lockdownMode,
  });

  @override
  int get hashCode => darkTheme.hashCode ^ devMode.hashCode ^ lockdownMode.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccountSettings &&
          runtimeType == other.runtimeType &&
          darkTheme == other.darkTheme &&
          devMode == other.devMode &&
          lockdownMode == other.lockdownMode;
}

class GroupData {
  final String mlsGroupId;
  final String nostrGroupId;
  final String name;
  final String description;
  final List<String> adminPubkeys;
  final String? lastMessageId;
  final BigInt? lastMessageAt;
  final GroupType groupType;
  final BigInt epoch;
  final GroupState state;

  const GroupData({
    required this.mlsGroupId,
    required this.nostrGroupId,
    required this.name,
    required this.description,
    required this.adminPubkeys,
    this.lastMessageId,
    this.lastMessageAt,
    required this.groupType,
    required this.epoch,
    required this.state,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      nostrGroupId.hashCode ^
      name.hashCode ^
      description.hashCode ^
      adminPubkeys.hashCode ^
      lastMessageId.hashCode ^
      lastMessageAt.hashCode ^
      groupType.hashCode ^
      epoch.hashCode ^
      state.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupData &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          nostrGroupId == other.nostrGroupId &&
          name == other.name &&
          description == other.description &&
          adminPubkeys == other.adminPubkeys &&
          lastMessageId == other.lastMessageId &&
          lastMessageAt == other.lastMessageAt &&
          groupType == other.groupType &&
          epoch == other.epoch &&
          state == other.state;
}

enum GroupState { active, inactive, pending }

enum GroupType { directMessage, group }

class OnboardingState {
  final bool inboxRelays;
  final bool keyPackageRelays;
  final bool keyPackagePublished;

  const OnboardingState({
    required this.inboxRelays,
    required this.keyPackageRelays,
    required this.keyPackagePublished,
  });

  @override
  int get hashCode =>
      inboxRelays.hashCode ^ keyPackageRelays.hashCode ^ keyPackagePublished.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OnboardingState &&
          runtimeType == other.runtimeType &&
          inboxRelays == other.inboxRelays &&
          keyPackageRelays == other.keyPackageRelays &&
          keyPackagePublished == other.keyPackagePublished;
}

class WhitenoiseConfigData {
  final String dataDir;
  final String logsDir;

  const WhitenoiseConfigData({required this.dataDir, required this.logsDir});

  @override
  int get hashCode => dataDir.hashCode ^ logsDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WhitenoiseConfigData &&
          runtimeType == other.runtimeType &&
          dataDir == other.dataDir &&
          logsDir == other.logsDir;
}
