// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../api.dart';
import '../frb_generated.dart';
import 'accounts.dart';
import 'groups.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Converts a core `MessageWithTokens` object to a Flutter-compatible `MessageWithTokensData` structure.
///
/// This function handles the conversion of complex message and token data to Flutter-compatible
/// formats, converting timestamps, public keys, and tokens to their string representations.
///
/// # Parameters
/// * `message_with_tokens` - Reference to a MessageWithTokens object from the core library
///
/// # Returns
/// A MessageWithTokensData struct with all fields converted for Flutter compatibility
///
/// # Notes
/// * Tokens are converted to debug string representations for simplicity
/// * All IDs and public keys are converted to hex format
/// * Timestamps are converted to u64 for JavaScript compatibility
Future<MessageWithTokensData> convertMessageWithTokensToData({
  required MessageWithTokens messageWithTokens,
}) => RustLib.instance.api.crateApiMessagesConvertMessageWithTokensToData(
  messageWithTokens: messageWithTokens,
);

/// Send a message to a group
///
/// This method sends a message to the specified group using the MLS protocol.
/// The message will be encrypted and delivered to all group members.
///
/// # Arguments
/// * `pubkey` - The public key of the account sending the message
/// * `group_id` - The MLS group ID to send the message to
/// * `message` - The message content as a string
/// * `kind` - The Nostr event kind (e.g., 1 for text message, 5 for delete)
/// * `tags` - Optional Nostr tags to include with the message (use the `tag_from_vec` helper function to convert a vec of strings to a tag)
///
/// # Returns
/// * `Ok(MessageWithTokensData)` - The sent message and parsed tokens if successful
/// * `Err(WhitenoiseError)` - If there was an error sending the message
Future<MessageWithTokensData> sendMessageToGroup({
  required PublicKey pubkey,
  required GroupId groupId,
  required String message,
  required int kind,
  List<Tag>? tags,
}) => RustLib.instance.api.crateApiMessagesSendMessageToGroup(
  pubkey: pubkey,
  groupId: groupId,
  message: message,
  kind: kind,
  tags: tags,
);

/// Fetches all messages for a specific MLS group.
///
/// This function retrieves messages that have been sent to the specified group,
/// including the decrypted content and associated token data for each message.
/// The messages are returned with their complete token representation, which
/// can be useful for debugging and understanding the message structure.
///
/// # Arguments
///
/// * `pubkey` - The public key of the account requesting the messages. This account
///   must be a member of the specified group to successfully fetch messages.
/// * `group_id` - The unique identifier of the MLS group to fetch messages from.
///
/// # Returns
///
/// Returns a `Result` containing:
/// - `Ok(Vec<MessageWithTokensData>)` - A vector of messages with their token data
/// - `Err(WhitenoiseError)` - If the operation fails (e.g., network error, access denied,
///   group not found, or user not a member of the group)
///
/// # Examples
///
/// ```rust
/// use whitenoise::PublicKey;
///
/// // Fetch messages for a group
/// let pubkey = PublicKey::from_string("npub1...")?;
/// let group_id = GroupId::from_hex("abc123...")?;
/// let messages = fetch_messages_for_group(&pubkey, group_id).await?;
///
/// println!("Fetched {} messages", messages.len());
/// for (i, message) in messages.iter().enumerate() {
///     println!("Message {}: {} tokens", i + 1, message.tokens.len());
/// }
/// ```
///
/// # Notes
///
/// - Messages are returned in chronological order (oldest first)
/// - Each message includes both the decrypted content and token representation
/// - Only group members can fetch messages from a group
/// - The token data should be used to construct the message content.
Future<List<MessageWithTokensData>> fetchMessagesForGroup({
  required PublicKey pubkey,
  required GroupId groupId,
}) => RustLib.instance.api.crateApiMessagesFetchMessagesForGroup(
  pubkey: pubkey,
  groupId: groupId,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessageWithTokens>>
abstract class MessageWithTokens implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Tag>>
abstract class Tag implements RustOpaqueInterface {}

class MessageWithTokensData {
  final String id;
  final String pubkey;
  final int kind;
  final BigInt createdAt;
  final String? content;
  final List<String> tokens;

  const MessageWithTokensData({
    required this.id,
    required this.pubkey,
    required this.kind,
    required this.createdAt,
    this.content,
    required this.tokens,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      pubkey.hashCode ^
      kind.hashCode ^
      createdAt.hashCode ^
      content.hashCode ^
      tokens.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageWithTokensData &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          pubkey == other.pubkey &&
          kind == other.kind &&
          createdAt == other.createdAt &&
          content == other.content &&
          tokens == other.tokens;
}
