// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../frb_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `GroupInformation`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`

Future<List<Group>> activeGroups({required String pubkey}) =>
    RustLib.instance.api.crateApiGroupsActiveGroups(pubkey: pubkey);

Future<List<String>> groupMembers({
  required String pubkey,
  required String groupId,
}) => RustLib.instance.api.crateApiGroupsGroupMembers(
  pubkey: pubkey,
  groupId: groupId,
);

Future<List<String>> groupAdmins({
  required String pubkey,
  required String groupId,
}) => RustLib.instance.api.crateApiGroupsGroupAdmins(
  pubkey: pubkey,
  groupId: groupId,
);

Future<Group> createGroup({
  required String creatorPubkey,
  required List<String> memberPubkeys,
  required List<String> adminPubkeys,
  required String groupName,
  required String groupDescription,
}) => RustLib.instance.api.crateApiGroupsCreateGroup(
  creatorPubkey: creatorPubkey,
  memberPubkeys: memberPubkeys,
  adminPubkeys: adminPubkeys,
  groupName: groupName,
  groupDescription: groupDescription,
);

Future<void> addMembersToGroup({
  required String pubkey,
  required String groupId,
  required List<String> memberPubkeys,
}) => RustLib.instance.api.crateApiGroupsAddMembersToGroup(
  pubkey: pubkey,
  groupId: groupId,
  memberPubkeys: memberPubkeys,
);

Future<void> removeMembersFromGroup({
  required String pubkey,
  required String groupId,
  required List<String> memberPubkeys,
}) => RustLib.instance.api.crateApiGroupsRemoveMembersFromGroup(
  pubkey: pubkey,
  groupId: groupId,
  memberPubkeys: memberPubkeys,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WhitenoiseError>>
abstract class WhitenoiseError implements RustOpaqueInterface {}

class Group {
  final String mlsGroupId;
  final String nostrGroupId;
  final String name;
  final String description;
  final String? imageUrl;
  final Uint8List? imageKey;
  final List<String> adminPubkeys;
  final String? lastMessageId;
  final DateTime? lastMessageAt;
  final BigInt epoch;
  final GroupState state;

  const Group({
    required this.mlsGroupId,
    required this.nostrGroupId,
    required this.name,
    required this.description,
    this.imageUrl,
    this.imageKey,
    required this.adminPubkeys,
    this.lastMessageId,
    this.lastMessageAt,
    required this.epoch,
    required this.state,
  });

  Future<GroupType> groupType() =>
      RustLib.instance.api.crateApiGroupsGroupGroupType(
        that: this,
      );

  Future<bool> isDirectMessageType() =>
      RustLib.instance.api.crateApiGroupsGroupIsDirectMessageType(
        that: this,
      );

  Future<bool> isGroupType() =>
      RustLib.instance.api.crateApiGroupsGroupIsGroupType(
        that: this,
      );

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      nostrGroupId.hashCode ^
      name.hashCode ^
      description.hashCode ^
      imageUrl.hashCode ^
      imageKey.hashCode ^
      adminPubkeys.hashCode ^
      lastMessageId.hashCode ^
      lastMessageAt.hashCode ^
      epoch.hashCode ^
      state.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Group &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          nostrGroupId == other.nostrGroupId &&
          name == other.name &&
          description == other.description &&
          imageUrl == other.imageUrl &&
          imageKey == other.imageKey &&
          adminPubkeys == other.adminPubkeys &&
          lastMessageId == other.lastMessageId &&
          lastMessageAt == other.lastMessageAt &&
          epoch == other.epoch &&
          state == other.state;
}

enum GroupState {
  active,
  inactive,
  pending,
}

enum GroupType {
  directMessage,
  group,
}
