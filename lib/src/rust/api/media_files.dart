// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../frb_generated.dart';
import 'error.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `from`, `from`

Future<MediaFile> uploadChatMedia({
  required String accountPubkey,
  required String groupId,
  required String filePath,
}) => RustLib.instance.api.crateApiMediaFilesUploadChatMedia(
  accountPubkey: accountPubkey,
  groupId: groupId,
  filePath: filePath,
);

class FileMetadata {
  final String? originalFilename;
  final String? dimensions;
  final String? blurhash;

  const FileMetadata({
    this.originalFilename,
    this.dimensions,
    this.blurhash,
  });

  @override
  int get hashCode => originalFilename.hashCode ^ dimensions.hashCode ^ blurhash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileMetadata &&
          runtimeType == other.runtimeType &&
          originalFilename == other.originalFilename &&
          dimensions == other.dimensions &&
          blurhash == other.blurhash;
}

class MediaFile {
  final String mlsGroupId;
  final String filePath;
  final String fileMimeType;
  final String fileMediaType;
  final String fileBlossomUrl;
  final FileMetadata? fileMetadata;
  final String? originalFilePath;

  const MediaFile({
    required this.mlsGroupId,
    required this.filePath,
    required this.fileMimeType,
    required this.fileMediaType,
    required this.fileBlossomUrl,
    this.fileMetadata,
    this.originalFilePath,
  });

  @override
  int get hashCode =>
      mlsGroupId.hashCode ^
      filePath.hashCode ^
      fileMimeType.hashCode ^
      fileMediaType.hashCode ^
      fileBlossomUrl.hashCode ^
      fileMetadata.hashCode ^
      originalFilePath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaFile &&
          runtimeType == other.runtimeType &&
          mlsGroupId == other.mlsGroupId &&
          filePath == other.filePath &&
          fileMimeType == other.fileMimeType &&
          fileMediaType == other.fileMediaType &&
          fileBlossomUrl == other.fileBlossomUrl &&
          fileMetadata == other.fileMetadata &&
          originalFilePath == other.originalFilePath;
}
