// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../api.dart';
import '../frb_generated.dart';
import 'utils.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Converts a core `Account` object to a Flutter-compatible `AccountData` structure.
///
/// This function bridges the gap between the core Whitenoise library's Account type
/// and the Flutter-compatible AccountData structure, converting complex types like
/// timestamps and public keys to their string representations.
///
/// # Parameters
/// * `account` - Reference to a core Account object
///
/// # Returns
/// An AccountData struct with all fields converted for Flutter compatibility
Future<AccountData> convertAccountToData({required Account account}) =>
    RustLib.instance.api.crateApiAccountsConvertAccountToData(account: account);

/// Fetch all accounts that are stored on the whitenoise instance (these are "logged in" accounts)
Future<List<AccountData>> fetchAccounts() => RustLib.instance.api.crateApiAccountsFetchAccounts();

/// Fetch an account by its public key
Future<AccountData> fetchAccount({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiAccountsFetchAccount(pubkey: pubkey);

/// Create a new account and get it ready for MLS messaging
Future<Account> createIdentity() => RustLib.instance.api.crateApiAccountsCreateIdentity();

/// Login to an account by its private key (nsec or hex)
Future<Account> login({required String nsecOrHexPrivkey}) =>
    RustLib.instance.api.crateApiAccountsLogin(nsecOrHexPrivkey: nsecOrHexPrivkey);

/// Logout of an account by its public key
Future<void> logout({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiAccountsLogout(pubkey: pubkey);

/// Export an account's private key (nsec)
Future<String> exportAccountNsec({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiAccountsExportAccountNsec(pubkey: pubkey);

/// Export an account's public key (npub)
Future<String> exportAccountNpub({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiAccountsExportAccountNpub(pubkey: pubkey);

/// Fetch an account's metadata by its public key
Future<MetadataData?> fetchMetadata({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiAccountsFetchMetadata(pubkey: pubkey);

/// Update an account's metadata
Future<void> updateMetadata({
  required MetadataData metadata,
  required PublicKey pubkey,
}) => RustLib.instance.api.crateApiAccountsUpdateMetadata(
  metadata: metadata,
  pubkey: pubkey,
);

/// Fetch an account's onboarding state by its public key
Future<OnboardingState> fetchOnboardingState({required PublicKey pubkey}) =>
    RustLib.instance.api.crateApiAccountsFetchOnboardingState(pubkey: pubkey);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Account>>
abstract class Account implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
abstract class PublicKey implements RustOpaqueInterface {}

class AccountData {
  final String pubkey;
  final AccountSettings settings;
  final OnboardingState onboarding;
  final BigInt lastSynced;

  const AccountData({
    required this.pubkey,
    required this.settings,
    required this.onboarding,
    required this.lastSynced,
  });

  @override
  int get hashCode =>
      pubkey.hashCode ^ settings.hashCode ^ onboarding.hashCode ^ lastSynced.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccountData &&
          runtimeType == other.runtimeType &&
          pubkey == other.pubkey &&
          settings == other.settings &&
          onboarding == other.onboarding &&
          lastSynced == other.lastSynced;
}

class AccountSettings {
  final bool darkTheme;
  final bool devMode;
  final bool lockdownMode;

  const AccountSettings({
    required this.darkTheme,
    required this.devMode,
    required this.lockdownMode,
  });

  @override
  int get hashCode => darkTheme.hashCode ^ devMode.hashCode ^ lockdownMode.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccountSettings &&
          runtimeType == other.runtimeType &&
          darkTheme == other.darkTheme &&
          devMode == other.devMode &&
          lockdownMode == other.lockdownMode;
}

class OnboardingState {
  final bool inboxRelays;
  final bool keyPackageRelays;
  final bool keyPackagePublished;

  const OnboardingState({
    required this.inboxRelays,
    required this.keyPackageRelays,
    required this.keyPackagePublished,
  });

  @override
  int get hashCode =>
      inboxRelays.hashCode ^ keyPackageRelays.hashCode ^ keyPackagePublished.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OnboardingState &&
          runtimeType == other.runtimeType &&
          inboxRelays == other.inboxRelays &&
          keyPackageRelays == other.keyPackageRelays &&
          keyPackagePublished == other.keyPackagePublished;
}
